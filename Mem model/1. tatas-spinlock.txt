Пример эффекта cache ping-pong: процессоры в цикле производят дорогостоящую операцию записи, но полезной работы не происходит.Пусть спинлок пытаются захватить несколько процессоров. Каждый из них постоянно вызывает RMW-операцию. Когда один фиксированный процессор X отправляет сигнал Read invalidate, все остальные вынуждены сигнализировать Invalidate Acknowledge. Процессор, пытавшийся захватить спинлок перед данным (у него кэш-линия в состоянии M), отправляет в Read Response “изменения” в Х и также инвалидирует кэш у себя. Только после этого Х выполняет попытку захвата.Если использовать TATAS алгоритм, то процессоры не будут требовать права на запись и закэшируют флаг в состоянии Shared. Из этого состояния они будут выведены только при освобождении спинлока, и никакой нагрузки на шину до тех пор не будет.При освобождение захваченного спинлока в случае TATAS, с некоторым шансом освобождающий процессор будет иметь эту кэш-линию в состоянии shared и не потребуется операция read/read response, но ждать подтверждения инвалидаций все равно придется. Иначе --  RMW из I в M. Но реальная работа действительно происходит.Для захватывающих процессоров в TASе поведение ничем не отличается от поведения при захваченном спинлоке: все, кроме одного, I->I, последний -- M-I. Следующий вызвавший RMW процессор получит право занять спинлок.В TATAS все процессоры были уведомлены об устаревании данных в кэше и вынуждены инвалидировать его. Сначала каждый возьмет его в виде Shared, а все те, кто успеет прочитать там 0 -- будут пытаться писать и вызовут некоторый ping-pong. 